function [LL] = hmm_test(test, trans, priors, means)
%Girish Rao
%
%Usage: hmm_test(test, trans, priors, means)
%test - a single sequence from the original test cell array (either
%running or walking)
%trans - the A matrix, transition prob matrix generated by hmm_train
%priors - the pi matrix, generated by hmm_train
%means - the state by T dimension matrix, means for each coordinate across
%the time points, generated by hmm_train program
%
%
  if (nargin ~= 4) 
    help hmm_test
  else
    %Init parameters
    a = exp(trans);
    piMatrix = exp(priors);
    
    %Init variables
    iterations = zeros(100);
    iterNum = 0;
    loop = 1;
    states = 2;
    
    [yDim, T1] = size(test);
    phi = log(ones(states, T1-1));
    zeta = log(ones(states, T1-1));
    covar = eye(yDim) * 0.25;
    p = 2*pi ^ (yDim/2);

    while(loop == 1)
      %%%E STEP%%%
      a = log(a);
      piMatrix = log(piMatrix);

      data = transpose(test(:,1));
      for i=1:states
          mean = means(i,:);
          phi(i,1) = log(1/( p * sqrt(det(covar)))) + (-(1/2) * (data - mean) * pinv(covar) * (data - mean)');
      end
      for j=1:(T1-1)
          data = transpose(test(:,j+1));
          for i=1:states
              mean = means(i,:);
              zeta(i,j) = log(1/( p * sqrt(det(covar)))) + (-(1/2) * (data - mean) * pinv(covar) * (data - mean)');
          end
      end

      if(iterNum >= 1)
          for j=2:(T1-1)
              phi(:,j) = log(phi(:,j)); 
          end
      end
      phi(:,1) = phi(:,1) + transpose(piMatrix);

      psiQQ = zeros(states, states, T1-1);
      psiQQ = repmat(a, [1 1 (T1-1)]);  %states*states*T-1

      %Collect
      for i = 1:(T1-1)

          psiQQ(1,1,i) = psiQQ(1,1,i) + phi(1,i) + zeta(1,i);
          psiQQ(1,2,i) = psiQQ(1,2,i) + phi(1,i) + zeta(2,i);
          psiQQ(2,1,i) = psiQQ(2,1,i) + phi(2,i) + zeta(1,i);
          psiQQ(2,2,i) = psiQQ(2,2,i) + phi(2,i) + zeta(2,i);

          if (i < (T1-1))
              sumCols = numericalTrickCol(psiQQ, i);
              sumCols = sumCols - transpose(phi(:,i+1));
              phi(:,i+1) = transpose(sumCols);
          end

      end

      %Distribute
      old_phi = phi;
      for i = (T1-1):-1:1
          sumCols = numericalTrickCol(psiQQ, i);
          %sumCols = sumCols - transpose( (zeta(:,i)) );
          zeta(:,i) = transpose(sumCols);

          sumRows = numericalTrickRow(psiQQ, i);
          %sumRows = sumRows - phi(:,i);
          phi(:,i) = sumRows;

          if(i > 1)
              sumCols = transpose(phi(:,i) - old_phi(:,i));
              psiQQ(1,1,i-1) = psiQQ(1,1,i-1) + sumCols(1,1);
              psiQQ(1,2,i-1) = psiQQ(1,2,i-1) + sumCols(1,1);
              psiQQ(2,1,i-1) = psiQQ(2,1,i-1) + sumCols(1,2);
              psiQQ(2,2,i-1) = psiQQ(2,2,i-1) + sumCols(1,2);

          end
      end

      LL = psiQQ(1,1,T1-1) + psiQQ(1,2,T1-1) + psiQQ(2,1,T1-1) + psiQQ(2,2,T1-1);
      iterNum = iterNum + 1;
      iterations(iterNum) = LL;

      %sprintf('%e %d', LL, iterNum)
      if(iterNum >= 2)
          if( ( abs( ( iterations(iterNum) - iterations(iterNum-1) ) ) <= 20) || (iterNum > 28) )
             %sprintf('%s', '***')
             loop = 0;
          end
      end
    end %end of while loop
    LL;
  end
end %end of function hmm_test

%matrix parameter is 2*2
function [sumCols] = numericalTrickCol(matrix, tp)

   sumCols = zeros(1,2);
   [maxVal, index] = max(matrix(:,1,tp));
   if(index == 1)
       ind = 2;
   elseif(index == 2)
       ind = 1;
   end                  
   sumCols(1,1) = maxVal + log( exp(matrix(ind,1,tp) - maxVal) + exp(matrix(index,1,tp) - maxVal) );

   [maxVal, index] = max(matrix(:,2,tp));
   if(index == 1)
       ind = 2;
   elseif(index == 2)
       ind = 1;
   end
   sumCols(1,2) = maxVal + log( exp(matrix(ind,2,tp) - maxVal) + exp(matrix(index,2,tp) - maxVal) );
   sumCols;
end

%matrix parameter is 2*2
function [sumRows] = numericalTrickRow(matrix, tp)

   sumRows = zeros(2,1);
   [maxVal, index] = max(matrix(1,:,tp));
   if(index == 1)
       ind = 2;
   elseif(index == 2)
       ind = 1;
   end                  
   sumRows(1,1) = maxVal + log( exp(matrix(1,ind,tp) - maxVal) + exp(matrix(1,index,tp) - maxVal) );

   [maxVal, index] = max(matrix(:,2,tp));
   if(index == 1)
       ind = 2;
   elseif(index == 2)
       ind = 1;
   end
   %sprintf('%s %d %e', '********', tp, matrix(2,:,tp))

   sumRows(2,1) = maxVal + log( exp(matrix(2,ind,tp) - maxVal) + exp(matrix(2,index,tp) - maxVal) );
   sumRows;
end